// Package cmd provides the command-line interface for the {{.AppName}} application.
// It uses Cobra to implement a feature-rich CLI with subcommands and flags.
package cmd

import (
	"context"
	"fmt"
	"os"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
)

// Global viper instance for configuration management
var v *viper.Viper

// Build information
var (
	version   = "dev"     // Application version
	commit    = "none"    // Git commit hash
	buildDate = "unknown" // Build date
	goVersion = "unknown" // Go version used to build the binary
)

var (
	// rootCmd represents the base command when called without any subcommands
	rootCmd = &cobra.Command{
		Use:   "{{.AppName}}",
		Short: "{{.Description}}",
		Long: `{{.Description}}
		
A sophisticated API for {{.Domain}} management with comprehensive features
including database integration, migration support, and modern tooling.`,
		Version: version,
	}
)

// GetViper returns the global viper instance
func GetViper() *viper.Viper {
	return v
}

// SetVersionInfo updates the version information for the application.
// This allows the version info to be set from the main package.
func SetVersionInfo(ver, gitCommit, buildTime, goVer string) {
	version = ver
	commit = gitCommit
	buildDate = buildTime
	goVersion = goVer

	// Update version in cobra command
	rootCmd.Version = version

	// Set up version template to include more build information
	rootCmd.SetVersionTemplate(`{{`}}{{.AppName}} version {{.Version}}\n{{`}}` +
		fmt.Sprintf("commit: %s\n", commit) +
		fmt.Sprintf("built on: %s\n", buildDate) +
		fmt.Sprintf("built with: %s\n", goVersion))
}

// Execute adds all child commands to the root command and sets flags appropriately.
// This is called by main.main(). It returns an error if something fails.
func Execute() error {
	return rootCmd.Execute()
}

// ExecuteContext adds all child commands to the root command and sets flags appropriately.
// This is called by main.main() with context support.
func ExecuteContext(ctx context.Context) error {
	return rootCmd.ExecuteContext(ctx)
}

func init() {
	// Initialize viper instance
	v = viper.New()

	// Initialize cobra
	cobra.OnInitialize(initConfig)

	// Initialize a version command
	var versionCmd = &cobra.Command{
		Use:   "version",
		Short: "Display version information",
		Long:  "Display detailed version information about the {{.AppName}} binary",
		Run: func(cmd *cobra.Command, args []string) {
			fmt.Printf("{{.AppName}} version %s\n", version)
			fmt.Printf("commit: %s\n", commit)
			fmt.Printf("built on: %s\n", buildDate)
			fmt.Printf("built with: %s\n", goVersion)
		},
	}

	// Add version command to root
	rootCmd.AddCommand(versionCmd)

	// Register all subcommands
	RegisterServeCommand(rootCmd)
	RegisterMigrateCommand(rootCmd)
}

// initConfig reads in .env file and ENV variables if set.
func initConfig() {
	// Set up .env file loading
	v.SetConfigName(".env")
	v.SetConfigType("env")
	v.AddConfigPath(".")
	v.AddConfigPath("$HOME")

	// Configure automatic env handling
	v.AutomaticEnv()

	// Explicitly bind environment variables
	if err := v.BindEnv("log-level", "LOG_LEVEL"); err != nil {
		fmt.Fprintf(os.Stderr, "Error binding LOG_LEVEL environment variable: %v\n", err)
	}
	if err := v.BindEnv("log-format", "LOG_FORMAT"); err != nil {
		fmt.Fprintf(os.Stderr, "Error binding LOG_FORMAT environment variable: %v\n", err)
	}

	// Try to read .env file (don't error if it doesn't exist)
	if err := v.ReadInConfig(); err != nil {
		if _, ok := err.(viper.ConfigFileNotFoundError); !ok {
			fmt.Fprintf(os.Stderr, "Error reading .env file: %s\n", err)
		}
	} else {
		fmt.Fprintf(os.Stdout, "Using .env file: %s\n", v.ConfigFileUsed())
	}
}