package cmd

import (
	"context"
	"fmt"
	"log/slog"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/go-chi/chi/v5"
	"github.com/go-chi/chi/v5/middleware"
	"github.com/spf13/cobra"

	"{{.ModuleName}}/internal/api"
	"{{.ModuleName}}/internal/service"
	"{{.ModuleName}}/internal/repository"
	"{{.ModuleName}}/internal/utils"
	"{{.ModuleName}}/internal/utils/database"
)

// serveCmd represents the serve command
var serveCmd = &cobra.Command{
	Use:   "serve",
	Short: "Start the {{.AppName}} API server",
	Long: `Start the {{.AppName}} API server with HTTP endpoints for {{.Domain}} management.
	
The server provides RESTful API endpoints for:
- {{.DomainTitle}} management
- Health checks
- Metrics and monitoring

Configuration is loaded from environment variables and .env files.`,
	RunE: runServe,
}

var (
	port string
	host string
)

func init() {
	serveCmd.Flags().StringVarP(&port, "port", "p", "8080", "Port to run the server on")
	serveCmd.Flags().StringVarP(&host, "host", "H", "0.0.0.0", "Host to bind the server to")
	
	// Bind flags to viper
	v.BindPFlag("port", serveCmd.Flags().Lookup("port"))
	v.BindPFlag("host", serveCmd.Flags().Lookup("host"))
}

func RegisterServeCommand(rootCmd *cobra.Command) {
	rootCmd.AddCommand(serveCmd)
}

func runServe(cmd *cobra.Command, args []string) error {
	ctx := cmd.Context()
	
	// Initialize logger
	logger := utils.NewLogger()
	slog.SetDefault(logger)
	
	// Get configuration
	port := v.GetString("port")
	host := v.GetString("host")
	
	slog.Info("Starting {{.AppName}} server", "host", host, "port", port)
	
	// Initialize database connection
	db, err := database.Connect(ctx)
	if err != nil {
		return fmt.Errorf("failed to connect to database: %w", err)
	}
	defer db.Close()
	
	// Initialize repository
	repo := repository.New(db)
	
	// Initialize service
	svc := service.New(repo)
	
	// Initialize API handler
	handler := api.New{{.DomainTitle}}Handler(svc)
	
	// Set up router
	r := chi.NewRouter()
	
	// Add middleware
	r.Use(middleware.Logger)
	r.Use(middleware.Recoverer)
	r.Use(middleware.RequestID)
	r.Use(middleware.RealIP)
	r.Use(middleware.Timeout(60 * time.Second))
	
	// Add routes
	api.RegisterRoutes(r, handler)
	
	// Create server
	server := &http.Server{
		Addr:    fmt.Sprintf("%s:%s", host, port),
		Handler: r,
	}
	
	// Start server in a goroutine
	go func() {
		slog.Info("Server starting", "address", server.Addr)
		if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			slog.Error("Server failed to start", "error", err)
		}
	}()
	
	// Wait for interrupt signal
	<-ctx.Done()
	
	// Graceful shutdown
	slog.Info("Shutting down server...")
	shutdownCtx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()
	
	if err := server.Shutdown(shutdownCtx); err != nil {
		slog.Error("Server forced to shutdown", "error", err)
		return err
	}
	
	slog.Info("Server exited")
	return nil
}